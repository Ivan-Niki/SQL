
---=================== SQL ===================---

/* Язык структурированных запросов (сокр. «SQL» от англ. «Structured Query Language») — это стандартный язык запросов, используемый для работы с реляционными базами данных. 
SQL используется для создания и удаления баз данных, создания и удаления таблиц в базе данных, чтения, вставки, обновления и удаления данных из таблиц, а также во многих других операций с базами данных.
База данных (БД) — это имеющая название совокупность данных, которая отражает состояние объектов и их отношений в рассматриваемой предметной области.
База данных (реляционная) — это совокупность множества таблиц, которые связаны между собой.
База данных (сокр. «БД») — это организованная коллекция данных, к которой можно легко получить доступ. 
Для управления базами данных используются системы управления базами данных (сокр. «СУБД»).

Типы баз данных:

I. --> Иерархические
Простейшая структура, где записи, как ветви, отходят от «родителя». Информация связана по аналогии с папками на рабочем столе. У каждой записи есть физическая связь только с одной предыдущей, а отношение многих ко многим невозможно.

II. --> Сетевые
Это тип БД, в которой данные организованы по принципу сети или связанной структуры. То есть у одной записи может быть несколько родительских и дочерних записей.


Есть два распространенных типа баз данных:
III. --> Реляционные базы данных (базы данных SQL).
IV.  --> Нереляционные (базы данных NoSQL).

------ Реляционные СУБД ------
В реляционных СУБД данные хранятся в табличном формате.
Первая строка — это атрибуты таблицы. Каждая последующая строка содержит фактические данные. 
В реляционных СУБД две или более таблиц могут быть связаны друг с другом. Отсюда и термин «реляционные» (англ. «relation» = «связь»).
Популярные реляционные СУБД: MySQL, PostgreSQL, MSSQL, Oracle и др.

Внешний ключ — это ограничение, которое СВЯЗЫВАЕТ указанную колонку с данными из другой таблицы. 
Такое ограничение гарантирует целостность данных. То есть попытка удалить данные, у которых есть зависимые данные, приведет к ошибке: */

CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id bigint REFERENCES products (id),
    quantity integer
);

/* В данной таблице атрибут product_id связан с атрибутом id таблицы products. 
Синтаксически для этого добавляется ключевое слово REFERENCES после типа поля. 
Затем добавляется имя таблицы, на которую идет связь. В скобках указывается поле, с которым эта связь создается. 
Наличие такой связи проявляется следующим образом:
- Если попробовать вставить в orders запись со значением product_id, которого нет в таблице products, то возникнет ошибка.
- Если попытаться удалить запись из products, на которую есть ссылки из таблицы orders, то возникнет ошибка.
Внешний ключ проверяет целостность данных и не позволяет появляться «мусору». 
Поэтому лучше ставить внешние ключи на все идентификаторы, для которых есть родительская таблица в базе. */

/*
--- Нереляционные СУБД ---
Они отличаются от реляционных тем, что в них для хранения используется не система из строк и столбцов, а
применяется модель, которая оптимизирована для хранения определённого типа содержимого. 
Например, данные могут храниться в виде документов JSON, графов, а также ключей-значений.
Кроме того, можно сказать, что нереляционные базы данных не используют язык запросов SQL, и вместо него запросы осуществляются с помощью иных языков и конструкций. 
Рассмотрим, какие типы NoSQL баз данных бывают.


--> 1) Хранилища документов (Документоориентированные базы данных)
Документоориентированные базы (например, MongoDB, Amazon DocumentDB, CouchDB, Firebase и др.) хранят данные сразу готовыми «документами», а не в таблицах и строках — как реляционные БД. 
Этот способ хранения подходит, когда структура данных может изменяться или ваши основные сценарии использования подразумевают загрузку составной структуры. 
Документоориентированные базы очень близки к формату ресурсов, которыми обмениваются клиент и сервер, что упрощает подготовку данных для передачи по сети.
Такой тип оперирует набором данных объекта, которые называются документом. 
Они хранятся в полях, которые могут быть представлены различными форматами, среди которых можно назвать такие, как XML, JSON, int и т.д.  
Набор данных и их полнота зависят от целей конкретного применения.
Причём здесь важным моментом является то, что в отличие от реляционной модели хранения, где данные одного объекта могут быть распределены по разным таблицам,
здесь они хранятся в одном документе, и этот тип хранения не требует, чтобы все документы имели одинаковую структуру, благодаря чему и достигается достаточно большая гибкость.

В статьях и книгах в качестве типового примера работы таких БД часто приводят сценарий загрузки страницы пользователя в социальной сети. В этом случае у человека есть основные данные: ФИО, дата рождения, пол — и дополнительная информация, которая может включать в себя несколько элементов и требовать разной структуры. Например, места учёбы, проживания, работы.



--> 2) Key-value-хранилища (хранение в виде «ключи-значения»)
Key-value-хранилища (Redis, Aerospike, DynamoDB и другие) хранят данные в виде хеш-таблицы. 
В такой модели у каждой записи есть только один индекс. При этом нет строгого ограничения на структуру значения. 
Как правило, такие базы данных изменяют данные по принципу логов, то есть всегда дописывают значения в конец, а удаление выполняется при помощи добавления специальной записи. 
Key-value-хранилища хорошо служат в качестве кэша, очереди или логирования.


--> 3) Графовые базы данных
Этот тип баз данных хранит информацию в графах. Графы — математический термин и означает совокупность двух множеств: множества объектов — вершин и множества парных связей этих объектов — ребер. 
Пример графа — дерево каталогов в компьютере: диски, папки и файлы — вершины, вложенность файлов и папок в папки и диски — ребра.
Графовый тип подходит, когда нужно получить информацию об основном объекте и об объектах, которые с ним связаны.
Пример проекта, в котором идеально использовать графовые базы данных, — обычная социальная сеть вроде ВК. Графовая база данных поможет быстро найти всю необходимую информацию не только нужного нам пользователя, но и всех его друзей, групп и сообществ.

Данный тип хранилища представляет собой хранение данных, содержащихся в узлах, а также определяет связь между узлами. 
Подобные хранилища позволяют достаточно оперативно выполнять запросы, которые проходят через ряд узлов и рёбер, и производить анализ взаимосвязей между узлами.
Такие структуры позволяют производить поиск, например, «всех сотрудников, работающих в определённом отделе» либо «находящихся в подчинении определённого руководителя» и т.д.


--> 4) Колоночные базы данных
Подобно реляционным, в этих базах данные хранятся в виде таблиц. Но структура колонок строго не регламентирована — они могут объединяться в колоночные семейства с определённым форматом. Строки колоночного семейства имеют уникальные идентификаторы.

Например, в колоночном семействе «Десерты» будут строки «Печенье» и «Круассаны».
В столбцовые (или колоночные) БД данные записывают в столбцы, а не в строки.
Колоночные БД удобны, когда нас интересует информация не во всех столбцах, а в каких-то конкретных. Искать по конкретным столбцам быстрее, чем по строкам.

*/

----------------- /* SELECT в SQL */ ------------------
/* Оператор SELECT в SQL используется для извлечения (выбора) данных из таблицы базы данных. 
Например: */
SELECT first_name, last_name
FROM Customers;
/* С помощью данной команды мы извлекаем (SELECT) имя (first_name) и фамилию (last_name) каждого клиента из таблицы Customers. */


------- SELECT * в SQL -------
-- Чтобы извлечь все столбцы из таблицы, используется символ *. Например:
SELECT *
FROM Customers;
-- Здесь мы извлекаем всё содержимое таблицы Customers.


/* 1. Вывести все столбцы из таблицы superheroes */
SELECT * FROM superheroes;

/* 2. Вывести столбцы name и appearances из таблицы superheroes */
SELECT name, appearances 
FROM superheroes;

/* 3. Псевдонимы столбцов в SELECT. */
/* в результате столбец с именем будет называться в выводе не name, а hero_name */
SELECT name AS hero_name, appearances 
FROM superheroes;


-------- SELECT DISTINCT в SQL ---------
/* Стейтмент SELECT DISTINCT извлекает уникальные данные из таблицы. 
Внутри таблицы в строках или столбцах данные могут повторяться, поэтому, когда нужно получить уникальные данные без дублей, используется SELECT DISTINCT. 
Например: */
SELECT DISTINCT country
FROM Customers;
-- Здесь мы выбираем список стран из таблицы Customers.

----- Рассмотрим другой пример:
SELECT DISTINCT country, first_name
FROM Customers;
----- Здесь мы выбираем строки, если комбинация страны (country) и имени (first_name) уникальна.


/* 4. Вывести только уникальные значения из столбца align из таблицы superheroes */
SELECT DISTINCT(align) 
FROM superheroes;


/* 5. Ограничение количества извлекаемых строк. ----- LIMIT и OFFSET -----
Указания LIMIT и OFFSET позволяют получить только часть строк из тех, что выдал остальной запрос.
Ключевое слово LIMIT используется для выбора фиксированного количества строк в MySQL, PostgreSQL и SQLite.
Например: выбрать (вывести) первые 2 строки из таблицы Customers.*/
SELECT first_name, age
FROM Customers
LIMIT 2;

/* Вывести только уникальные значения из столбца hair из таблицы superheroes и ограничить результат только первыми 10-ю строками */
SELECT DISTINCT(hair) 
FROM superheroes
LIMIT 10;

/* Ключевое слово OFFSET используется для указания места, откуда следует выбирать строки. Например: */
SELECT first_name, last_name
FROM Customers
LIMIT 2 OFFSET 3;
/* Здесь мы выбираем две строки, начиная с четвертой строки. OFFSET 3 означает, что первые 3 строки исключены. */



/* ========================================================================== */
---------------- /* Data filtration (Оператор WHERE)*/ ----------------

/* 6. Оператор SQL WHERE используется для фильтрации результатов и применения условий в предложениях SELECT, INSERT, UPDATE или DELETE.
/* Указать, какие строки хотим выбрать. Вывести все строки из таблицы superheroes, в которых значение в столбце gender = 'Female Characters' */
SELECT * 
FROM superheroes
WHERE gender = 'Female Characters';


/* 7. Операторы для использования в фильтрах */
/*
    =          --->      Равно
    <>, !=     --->      Неравно
    >          --->      Больше
    >=         --->      Больше или равно
    <          --->      Меньше
    <=         --->      Меньше или равно
    between    --->      Проверка нахождения в указанном диапазоне
    in         --->      Проверка вхождения в список
    like       --->      Проверка строки на соответствие шаблону
*/


------------ Использование BETWEEN в WHERE -----------
/* BETWEEN – это логический оператор языка SQL, который определяет диапазон для проверки. 
Другими словами, с помощью BETWEEN мы можем проверить, входит ли значение в определённый диапазон. */
/* Вывести все строки из таблицы superheroes, в которых значение в столбце year находится 
в диапазоне от 2000 до 2005 */
SELECT * 
FROM superheroes
WHERE year BETWEEN 2000 AND 2005;

/* С помощью ключевого слова NOT мы можем инвертировать результат, иными словами, NOT BETWEEN означает, что мы хотим проверить значение на предмет того, что оно не входит в заданный диапазон.

/* Вывести все строки из таблицы superheroes, в которых значение в столбце year НЕ находится 
в диапазоне от 2000 до 2005 */
SELECT * 
FROM superheroes
WHERE year NOT BETWEEN 2000 AND 2005;


----------- Использование IN в WHERE ------------
/* Оператор IN позволяет легко проверить, соответствует ли выражение какому-либо значению в списке значений. Он используется, чтобы помочь уменьшить потребность в нескольких условиях OR в операторе SELECT, INSERT, UPDATE или DELETE.

Синтаксис оператора IN в SQL:
expression IN (value1, value2, .... value_n);
	Или
expression IN (subquery); */

/* Вывести все строки из таблицы superheroes, в которых значение в столбце hair входит в список (перечисление) */
SELECT * 
FROM superheroes
WHERE hair IN ('Strawberry Blond Hair', 'Red Hair', 'Auburn Hair');


/* Использование LIKE в WHERE
LIKE используется для того, чтобы сравнить нужные строки с шаблоном. В шаблонах используются два специальных символа:
% (процент) - любое количество символов (в том числе 0);
_ (нижнее подчеркивание) - обозначает ровно один символ;

Вывести все строки из таблицы superheroes, в которых значение в столбце hair содержит вхождение Blond */
SELECT * 
FROM superheroes
WHERE hair LIKE ('%Blond%');



/* 8. Логические операции для использования в фильтрах с WHERE */
/*
    AND         --->     Логическое И
    OR          --->     Логическое ИЛИ 
    NOT         --->     Логическое НЕ 
*/

/* Использование AND в WHERE
AND будет верным в случае выполнения обоих выражений, которые входят в условие.
/* Вывести все строки из таблицы superheroes, в которых значение в столбце gender = 'Female Characters' и одновременно с этим значение в столбце align = 'Bad Characters' */
SELECT * 
FROM superheroes
WHERE gender = 'Female Characters'
      AND 
	  align = 'Bad Characters';
	  

/* Использование OR в WHERE
OR будет верным в случае выполнения хотя бы одного из выражений, которые входят в условие.
/* Вывести все строки из таблицы superheroes, в которых значение в столбце gender = 'Female Characters' ЛИБО значение в столбце align = 'Bad Characters' */
SELECT * 
FROM superheroes
WHERE hair = 'Red Hair'
 OR hair = 'Strawberry Blond Hair'
 OR hair = 'Auburn Hair';   /* то же самое можно выполнить при помощи IN (см. выше)*/
 
/* Использование NOT в WHERE 
Вывести все строки из таблицы superheroes, в которых значение в столбце hair НЕ ВХОДИТ в список (перечисление) */
SELECT * 
FROM superheroes
WHERE hair NOT IN ('Blond Hair', 'Black Hair', 'Brown Hair', 'Red Hair');

/* ========================================================================== */
--------- Работа с NULL-значениями в SQL ---------

/* Условие IS NULL используется для выбора строк, в которых указанное поле имеет значение NULL. Условие IS NOT NULL используется для выбора строк, в которых указанное поле НЕ является NULL. Можно использовать функцию COUNT() с условием IS NULL для подсчета количества пустых строк. */

----- Условие IS NULL в SQL -----
/* Условие IS NULL используется для выбора строк, в которых указанное поле имеет значение NULL. 
Например: выбрать (вывести) сотрудников, у которых нет электронной почты. */
SELECT *
FROM Employee
WHERE email IS NULL;

----- Условие IS NOT NULL в SQL -----
/* Условие IS NOT NULL используется для выбора строк, в которых указанное поле НЕ является NULL. 
Например: выбрать (вывести) сотрудников, у которых есть электронная почта. */
SELECT *
FROM Employee
WHERE email IS NOT NULL;

----- Условие IS NULL с функцией COUNT() -----
/* Можно использовать функцию COUNT() с условием IS NULL для подсчета количества пустых строк. 
Например: выбрать (вывести) общее количество сотрудников, у которых нет электронной почты. */
SELECT COUNT(*)
FROM Employee
WHERE email IS NULL;


/* ========================================================================== */

-------- Sorting of Data (ORDER BY) --------
------- Оператор ORDER BY в SQL --------

/* Оператор ORDER BY используется для сортировки данных в порядке возрастания или убывания. 
Например: выбрать (вывести) всех клиентов, а затем отсортировать их в порядке возрастания по имени (first_name).*/
SELECT *
FROM Customers
ORDER BY first_name;

/* 9. Вывести все данные из таблицы superheroes и отсортировать их по столбцу year */
SELECT * 
FROM superheroes
ORDER BY year;

/* Порядок сортировки в ORDER BY */
/*
    ASC  (ascending)    --->   Сортировка по возрастанию
    DESC (descending)   --->   Сортировка по убыванию
    
	по умолчанию применяется сортировка по возрастанию (ASC)
*/


/* Вывести все данные из таблицы superheroes и отсортировать их по столбцу appearances в порядке убываения, т.е. сначала будут идти супергерои, у которых значение в столбце appearances максимальное */
SELECT * 
FROM superheroes
ORDER BY appearances DESC;

/* Можно использовать одновременно и сортировку и фильтры в SELECT */
/* Вывести все данные из таблицы superheroes, в которых значение в столбце align = 'Bad Characters' и отсортировать их по столбцу appearances в порядке убывания */
SELECT * 
FROM superheroes
WHERE align = 'Bad Characters'
ORDER BY appearances DESC;

/* Вывести все данные из таблицы superheroes, в которых значение в столбце align = 'Bad Characters' и одновременно с эти значение в столбце gender = 'Female Characters' и отсортировать их по столбцу appearances в порядке убывания и ограничить количество выводимых строк (5 строк) */
SELECT * 
FROM superheroes
WHERE align = 'Bad Characters'
AND gender = 'Female Characters'
ORDER BY appearances DESC
LIMIT 5;


/* Сортировка по нескольким столбцам */
/* Вывести все данные из таблицы superheroes и отсортировать их по году появления (year), а внутри каждого года по количеству появлений (appearances) в порядке возрастания (по умолчанию) */
SELECT * 
FROM superheroes
ORDER BY year, appearances;


/* ========================================================================== */
/* СОЗДАНИЕ БАЗ ДАННЫХ (CREATE DATABASE) в SQL */
/* Прежде чем мы сможем работать с таблицами базы данных, нам сначала нужно создать базу данных.
Оператор CREATE DATABASE используется для создания базы данных. Например: */
CREATE DATABASE my_db;

/* В системе управления базами данных (СУБД) может быть несколько баз данных. Чтобы посмотреть список всех баз данных, мы можем использовать следующую команду: */
SHOW DATABASES;

------- Переключиение между базами данных в SQL -------
/* Время от времени приходится работать с несколькими базами данных. Чтобы переключаться между доступными БД, мы можем использовать следующую команду: */
USE my_db;
/* Здесь мы выбираем базу данных my_db, и все последующие SQL-операции будут выполняться внутри этой базы данных. */



------- УДАЛЕНИЕ БАЗ ДАННЫХ (DROP DATABASE) в SQL -------
/* Инструкция DROP DATABASE используется для удаления базы данных в системе управления базами данных (СУБД). 
Например: */
DROP DATABASE my_db;




/* ========================================================================== */

/* Creation and Modification (alteration) of tables (CREATE TABLE; ALTER TABLE; ...) */

/* Создать таблицу superheroes с указанными столбцами (список столбцов указывается в скобках, для каждого столбца указывается ИМЯ столбца (например, id, name, hair, eye и т.д.) и ТИП данных для данного столбца (например, INT, VARCHAR и т.д. */
CREATE TABLE superheroes (
	id INT,
	name VARCHAR(100),
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
)


/* ТИПЫ ДАННЫХ в SQL */

/*
   CHARACTER(n)         (CHAR(n))       --->   Строка фиксированной длины n
   CHARACTER VARYING(n) (VARCHAR(n))    --->   Строка переменной длины, максимальная длина n
   BOOLEAN                              --->   Логический тип данных
   INTEGER (INT)                        --->   Целое число
   NUMERIC(p,s)                         --->   Действительное число (p - количество згачащих цифр,
                                               s - количество цифр после запятой). Хранится точно.
   REAL                                 --->   Действительное число одинарной точности, формат IEEE 754
   DOUBLE PRECISION                     --->   Действительное число двойной точности, формат IEEE 754
   DATE                                 --->   Дата
   TIMESTAMP                            --->   Дата и время
*/


/* ПЕРВИЧНЫЙ КЛЮЧ В ТАБЛИЦЕ (PRIMARY KEY) */
CREATE TABLE superheroes (
	id INT PRIMARY KEY,
	name VARCHAR(100),
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
)

/* АВТОМАТИЧЕСКОЕ ЗАПОЛНЕНИЕ ПЕРВИЧНОГО КЛЮЧА В ТАБЛИЦЕ (ключевое слово SERIAL) */
/* SERIAL - каждый раз, когда мы вставлем запись в таблицу superheroes, идентификатор будет высчитываться автоматически (будет выбираться следующее значение целого числа (типа INT), которое ранее ещё не использовалось для вставки в таблицу) */
/* Другие базы данных для этой функциональности используют другие ключевые слова (например, в MySQL используется ключевое слово AUTO_INCREMENT */

CREATE TABLE superheroes (
	id SERIAL PRIMARY KEY,
	name VARCHAR(100),
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
);

----- Создание таблицы, используя записи из другой таблицы (CREATE TABLE AS) -----
/* Мы также можем создать таблицу, используя записи из любой другой существующей таблицы, используя команду CREATE TABLE AS. Например: */
CREATE TABLE JapanCustomers
AS (
  SELECT *
  FROM Customers
  WHERE country = 'Japan'
);
/* Здесь мы создаем таблицу с именем JapanCustomers и копируем в нее записи из вложенного запроса. */


/* ПРОСМОТР СВЕДЕНИЙ О ТАБЛИЦЕ
В Postgres: \d superheroes; --- для просмотра информации о таблице superheroes в командной строке
В Oracle и MySQL: describe superheroes;
*/


------- УДАЛЕНИЕ ТАБЛИЦ (DROP TABLE) -------
/* Оператор DROP TABLE используется для удаления таблиц в базе данных. 
Например: Удалить таблицу superheroes */
DROP TABLE superheroes;



---------------------- ИЗМЕНЕНИЕ ТАБЛИЦ (ALTER TABLE) --------------------
/* Мы можем изменить структуру таблицы с помощью команды ALTER TABLE. */
--- Мы можем: 
--> Добавить столбец.
--> Переименовать столбец.
--> Изменить столбец.
--> Удалить столбец.
--> Переименовать таблицу.

-------------------- ДОБАВЛЕНИЕ СТОЛБЦА (или нескольких СТОЛБЦОВ) --------------------
/* Мы можем добавить столбцы в таблицу с помощью команды ALTER TABLE с оператором ADD. Например: */
----- Добавить столбец в таблицу superheroes -----
ALTER TABLE superheroes ADD COLUMN alive BOOLEAN; -- добавить столбец alive с типом данных BOOLEAN

/* Добавить столбец first_appearance с типом данных TIMESTAMP 
(то есть столбец будет содержать информацию с днём, месяцем и годом) */
ALTER TABLE superheroes ADD COLUMN first_appearance TIMESTAMP;

----- Добавить столбец с именем phone в таблицу Customers с типом данных varchar(10).
ALTER TABLE Customers
ADD phone varchar(10);

----- Мы также можем добавить сразу НЕСКОЛЬКО столбцов в таблицу. Например:
ALTER TABLE Customers
ADD phone varchar(10), age int;


-------------------- ПЕРЕИМЕНОВАНИЕ СТОЛБЦА / ПРЕИМЕНОВАНИЕ ТАБЛИЦЫ --------------------
/* Мы можем переименовать столбцы в таблице с помощью команды ALTER TABLE с оператором RENAME COLUMN. 
Например: */
----- Переименовать столбец name в hero_name -----
ALTER TABLE superheroes 
RENAME COLUMN name TO hero_name;

----- Переименовать столбец (изменить имя столбца) customer_id на c_id в таблице Customers.
ALTER TABLE Customers
RENAME COLUMN customer_id TO c_id;

----- Переименовать таблицу superheroes (присвоить ей имя comic_characters) -----
ALTER TABLE superheroes 
RENAME TO comic_characters;

----- Переименовать таблицу Customers в newCustomers -----
ALTER TABLE Customers
RENAME TO newCustomers;


---------------------- УДАЛЕНИЕ СТОЛБЦА ----------------------
/* Мы также можем удалить столбцы в таблице с помощью команды ALTER TABLE с оператором DROP. Например: */
----- Удалить столбец year в таблице superheroes -----
ALTER TABLE superheroes 
DROP COLUMN year;

----- Удалить столбец age из таблицы Customers -----
ALTER TABLE Customers
DROP COLUMN age;


---------------------- ИЗМЕНЕНИЕ ТИПА ДАННЫХ СТОЛБЦА ----------------------
/* Для изменения типа данных столбца в PostgresQL применяется команда ALTER TABLE с оператором ALTER COLUMN и ключевым словом TYPE. Например:
Изменим в таблице Customers тип данных у столбца FirstName на VARCHAR(50): */
ALTER TABLE Customers
ALTER COLUMN FirstName TYPE VARCHAR(50);

/* Примечание: в других СУБД для этой цели используются другие ключевые слова (например: MODIFY COLUMN для MySQL, MODIFY для Oracle и др.
* /



/* ========================================================================== */
---=== /* ВСТАВКА ДАННЫХ в SQL (INSERT INTO (...) VALUES (...)) */ ===---

-- Оператор INSERT INTO используется для вставки новых строк в таблицу. 
-- Например:
INSERT INTO Customers(customer_id, first_name, last_name, age, country)
VALUES
(5, 'Harry', 'Potter', 31, 'USA');
--- Здесь мы вставляем новую строку с указанными значениями в таблицу Customers.

/* В таблице поле с идентификатором обычно является уникальным и автоматически увеличивается на единицу. В таких случаях мы можем не указывать значение для этого столбца при вставке строки. Например: */
INSERT INTO Customers(first_name, last_name, age, country)
VALUES
('James', 'Bond', 48, 'USA');
-- Здесь SQL автоматически устанавливает новый customer_id для новой строки и вставляет его в таблицу.


----- Вставить сразу несколько строк -----
--- Можно вставить сразу несколько строк в таблицу. Например:
INSERT INTO Customers(first_name, last_name, age, country)
VALUES
('Harry', 'Potter', 31, 'USA'),
('Chris', 'Hemsworth', 43, 'USA'),
('Tom', 'Holland', 26, 'UK');

----- Вставка строк без указания имен столбцов -----
--- Можно вставлять значения без указания имен столбцов. Например:
INSERT INTO Customers
VALUES
(5, 'Chris', 'Evans', 42, 'USA');
--- Здесь мы вставляем новую строку в столбец, указав при этом корректный порядок значений.
/* Примечание: Если явно не указывать имена столбцов, то порядок значений в SQL-запросе должен соответствовать порядку столбцов в таблице. */

--- Пропуск значений при вставке строки  -----
--- Если пропустить имена столбцов во время вставки строки, то значениями этих столбцов будет NULL.
INSERT INTO Customers(first_name, last_name, age)
VALUES
('Brad', 'Pitt', 58);
/* Здесь значением столбца country (последний столбец, который мы пропустили) будет NULL. Однако столбец с идентификатором (customer_id) по-прежнему будет увеличен на единицу из-за принципа автоматического инкремента. */

--- Ещё один пример INSERT INTO:
/* Вставить в таблицу superheroes (перечисляем поля, в которые хотим вставить данные) 
значения (перечисляем значения) */
INSERT INTO superheroes(name, appearances, universe) 
VALUES ('Spider-Man', 4043, 'marvel');




/* ========================================================================== */
---=== /* Редактирование существующих строк в таблице (UPDATE) */ ===---

--- Оператор UPDATE используется для редактирования существующих строк в таблице. Например:
UPDATE Customers
SET first_name = 'Johnny'
WHERE customer_id = 1;
-- Здесь мы изменяем значение столбца first_name на Johnny, где customer_id равен 1.


--- Можно обновить сразу несколько значений в строке. Например:
UPDATE Customers
SET first_name = 'Johnny', last_name = 'Depp'
WHERE customer_id = 1;
-- Здесь мы изменяем значение столбца first_name на Johnny, а last_name на Depp, где customer_id равен 1.


--- Обновить несколько строк ---
--- Можно обновить сразу несколько строк. Например:
UPDATE Customers
SET country = 'NP'
WHERE age = 22;
/* Здесь мы изменяем значение столбца country на NP, если значением столбца age является 22. 
Если имеется более одной строки с возрастом, равным 22, все соответствующие строки будут отредактированы. */


--- Обновить все строки ---
/* Мы можем обновить сразу все строки в таблице. Для этого нужно просто не указывать оператор WHERE. 
Например: */
UPDATE Customers
SET country = 'NP';
-- Здесь мы изменяем значение столбца country на NP для всех строк.


--- Примеры UPDATE:
/* Изменить данные в таблице superheroes для одной строки (идентификатор id=1) */
UPDATE superheroes
SET name='Batman',
	universe='dc'
WHERE id=1;

/* Изменить данные в таблице superheroes для нескольких строк */
UPDATE superheroes
SET gender='Man',
WHERE gender='Male Characters';



/* ========================================================================== */
---=== /* УДАЛЕНИЕ существующих строк в таблице (DELETE) */ ===---

/* Оператор DELETE FROM используется для удаления строк в таблице. Например: */
DELETE FROM superheroes
WHERE id=2;
/* Здесь мы удаляем строку из таблицы superheroes, где id равен 2. */

/* Удаление данных из таблицы superheroes (удалить несколько строк по фильтру) */
DELETE FROM superheroes
WHERE gender='Male Characters';

------- Удаление всех строк в таблице -------
/* С помощью оператора WHERE мы можем указать, какие строки следует удалить. 
Однако если нужно удалить сразу все строки, то достаточно просто не указывать оператор WHERE.
Например: Удалить всех данных из таблицы superheroes */
DELETE FROM superheroes;  --- Здесь мы удаляем все строки из таблицы superheroes.
DELETE FROM Customers;    --- Здесь мы удаляем все строки из таблицы Customers.



/* Оператор TRUNCATE TABLE — это еще один способ одновременного удаления сразу всех строк в таблице. 
Например: */
TRUNCATE TABLE Customers;
/* Здесь мы делаем то же самое, что и выше — удаляем все строки из таблицы Customers.
Примечание: Оператор TRUNCATE TABLE нельзя использовать в связке с оператором WHERE. */
/* Мы можем выполнить работу оператора TRUNCATE TABLE оператором DELETE FROM, просто не указывая оператор WHERE. Например, следующий код: */

DELETE FROM Customers;

-- идентичен

TRUNCATE TABLE Customers;

/* Основное различие между обоими операторами заключается в том, что оператор DELETE FROM может использоваться в связке с оператором WHERE, а TRUNCATE TABLE — нет. 
Это означает, что мы можем удалить одну или несколько строк, используя оператор DELETE FROM, в то время как оператор TRUNCATE TABLE удаляет сразу всё содержимое таблицы. 

1. DELETE записывает в журнал транзакций удаление каждой строки.
   TRUNCATE TABLE удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций.
   
2. DELETE сохраняет счетчик идентификаторов и не сбрасывает его до начального значения.
   TRUNCATE TABLE сбрасывает счетчик идентификаторов до начального значения.
   
3. DELETE может удалить часть данных за счет использования WHERE.
   TRUNCATE TABLE удаляет все данные из таблицы, секцию WHERE использовать нельзя.
   
4. DELETE удаляет строки по одной за раз.
   TRUNCATE TABLE удаляет все строки в таблице путем освобождения страниц.
   
5. DELETE выполняется медленнее.
   TRUNCATE TABLE выполняется быстрее также за счет меньшего использования журнала транзакций.

6. -> DELETE имеет возможность отката, т.к. система ведет журнал удаленных файлов. 
   Эти файлы могут быть восстановлены программистом при необходимости. 
   -> TRUNCATE не позволяет откат или отмену опции. 
   Как только файлы удалены, они навсегда исчезли из системы.
   Отсутствие ведения журналов делает функцию TRUNCATE более быстрой, чем функция DELETE.
*/



/* ========================================================================== */
------------------------ АГРЕГАТНЫЕ ФУНКЦИИ ------------------------
/* Агрегатные функции используются совместно с группировкой */

/* Вывести группы супергероев по типу (align) и для каждой группы подсчитать общее количество супергероев в группе */
SELECT align, COUNT(*)
FROM superheroes
GROUP BY align;

/* АГРЕГАТНЫЕ ФУНКЦИИ В SQL */

/*
    COUNT(ключ)          --->     Количество элементов в заданной группе
	SUM(столбец)         --->     Сумма значений в заданной группе - только для числовых данных
	AVG(столбец)         --->     Среднее по заданным значениям в группе - только для числовых данных
    MAX(столбец)         --->     Максимальное значение в группе - только для числовых данных и дат
	MIN(столбец)         --->     Минимальное значение - только для числовых данных и дат
*/

/* Вывести группы супергероев по типу (align) и для каждой группы подсчитать общее количество супергероев в группе, а также сумму появлений супергероев этой группы  */
SELECT align, COUNT(*), SUM(appearances)
FROM superheroes
GROUP BY align;

/* Вывести группы супергероев по типу (align) и для каждой группы подсчитать общее количество супергероев в группе, а также среднее значение появлений супергероев этой группы  */
SELECT align, COUNT(*), AVG(appearances)
FROM superheroes
GROUP BY align;

/* Вывести группы супергероев по годам (year) и для каждой группы подсчитать минимальное количество появлений (appearances) супергероев в группе, а также максимальное количество появлений (appearances) супергероев этой группы  */
SELECT year, MIN(appearances), MAX(appearances)
FROM superheroes
GROUP BY year;

/* Вывести группы супергероев по годам (year) и для каждой группы подсчитать минимальное количество появлений (appearances) супергероев в группе, а также максимальное количество появлений (appearances) супергероев этой группы, а также отсортировать по годам в порядке убывания  */
SELECT year, MIN(appearances), MAX(appearances)
FROM superheroes
GROUP BY year
ORDER BY year DESC;

/* Вывести группы супергероев по годам (year) и для каждой группы подсчитать минимальное количество появлений (appearances) супергероев в группе, а также максимальное количество появлений (appearances) супергероев этой группы, а также отсортировать по столбцу со значениями MAX в порядке убывания  */
SELECT year, MIN(appearances), MAX(appearances)
FROM superheroes
GROUP BY year
ORDER BY MAX(appearances) DESC;


------------- /* Использование Alias */ --------------
/* Вывести группы супергероев по годам (year) и для каждой группы подсчитать минимальное количество появлений (appearances) супергероев в группе, а также максимальное количество появлений (appearances) супергероев этой группы (как max_appear), а также отсортировать по столбцу со значениями MAX в порядке убывания, и ограничить количество выдаваемых строк 5-ю */
SELECT year, MIN(appearances), 
	MAX(appearances) AS max_appear
FROM superheroes
GROUP BY year
ORDER BY max_appear DESC
LIMIT 5;

/* Использование АГРЕГАТНЫХ ФУНКЦИЙ без группировки. 
В таком случае вся таблица будет считаться как одна большая группа */
/* Рассчитать общее количество строк в таблице супергероев, минимальное количество появлений супергероя (по всей таблице), максимальное количество появлений супергероя (по всей таблице), общую сумму появлений всех супергероев в комиксах, и среднее значение появлений супергероев в комиксах для всей таблицы */
/* Результатом будет одна строка, так как у нас одна группа, которая соответствует всей таблице */
SELECT COUNT(*),
	MIN(appearances),
	MAX(appearances),
	SUM(appearances),
	AVG(appearances)
FROM superheroes;



/* ========================================================================== */
---------------- Оператор GROUP BY в SQL ----------------

/* Оператор GROUP BY используется для группировки строк по одному или нескольким столбцам. 
Например: */
SELECT country, COUNT(*) AS number
FROM Customers
GROUP BY country;
/* Здесь мы группируем строки по столбцу country и подсчитываем количество записей для каждой страны (используя функцию COUNT()). */

/* Рассмотрим другой пример. Попробуем найти общую сумму заказов для каждого клиента: */
SELECT customer_id, SUM(amount) AS total
FROM Orders
GROUP BY customer_id;
/* Здесь мы суммируем значения столбца amount после группировки строк по идентификатору customer_id. */



/* ========================================================================== */
----------- /* HAVING --> ФИЛЬТРАЦИЯ РЕЗУЛЬТАТОВ ГРУППИРОВКИ */ -----------

/* Оператор HAVING в SQL используется, когда нужно отфильтровать данные на основе агрегатных функций, таких как MIN() и MAX(), SUM() и AVG() и COUNT(). */
-- Например:
SELECT COUNT(customer_id), country
FROM Customers
GROUP BY country
HAVING COUNT(customer_id) > 1;
-- Здесь мы подсчитываем количество клиентов (customer_id), группируя их по странам (country), а затем возвращаем результат, если на страну имеется больше 1 клиента.

/* Примечание: Оператор HAVING добавили из-за того, что оператор WHERE не поддерживает агрегатные функции. Кроме того, перед оператором HAVING необходимо использовать GROUP BY. */

-- Примеры использования GROUP BY и HAVING:
/* Вывести группы супергероев по волосам (hair) только ЖЕНСКОГО пола и для каждой группы подсчитать общее количество супергероев в группе */
SELECT hair, COUNT(*)
FROM superheroes WHERE gender='Female Characters'
GROUP BY hair;

/* Вывести группы супергероев по волосам (hair) только ЖЕНСКОГО пола и для каждой группы подсчитать общее количество супергероев в группе, и отфильтровать результаты группировки по количеству супергероев в группе (вывести только группы, в которых больше 10 супергероев) */
SELECT hair, COUNT(*)
FROM superheroes WHERE gender='Female Characters'
GROUP BY hair
HAVING COUNT(*) > 10;

/* Вывести группы супергероев по волосам (hair) только ЖЕНСКОГО пола и для каждой группы подсчитать общее количество супергероев в группе, и отфильтровать результаты группировки по количеству супергероев в группе (вывести только группы, в которых от 50 до 300 супергероев) */
SELECT hair, COUNT(*)
FROM superheroes WHERE gender='Female Characters'
GROUP BY hair
HAVING COUNT(*) BETWEEN 50 AND 300;

/* Таким образом, для фильтрации данных можно использовать два ключевых слова:
	WHERE    ---> Используется для фильтрации строк в исходной таблице;
	HAVING   ---> Используется для фильтрации результатов группировки;


	ПОРЯДОК ВЫПОЛНЕНИЯ SELECT:
		Выбор таблицы: FROM
		Фильтрация строк из таблицы: WHERE
		Группировка: GROUP BY
		Фильтрация результатов группировки: HAVING

*/


/* ========================================================================== */

--------------- /* СВЯЗЬ МЕЖДУ ТАБЛИЦАМИ */ ----------------
/* Связь достигается с помощью дополнительного столбца (foreign key) (внешний ключ).
Например, есть две таблицы: 1)superheroes; 2)movies. 
Для связи между двумя таблицами в таблице movies создан столбец superhero_id (foreign key), 
который содержит значения, которые находятся в столбце id таблицы superheros, на которые ссылается этот внешний ключ */



/* ========================================================================== */
------------ /* JOIN --> ЗАПРОС ДАННЫХ ИЗ НЕСКОЛЬКИХ ТАБЛИЦ */ ------------

/* Оператор JOIN объединяет две таблицы на основе общего столбца и выбирает записи с совпадающими значениями в этих столбцах. Например: */
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
JOIN Orders
ON Customers.customer_id = Orders.customer;
/* Здесь мы выбираем столбцы customer_id и first_name (из таблицы Customers) и столбец amount (из таблицы Orders). 
В результате получаем те строки, в которых есть совпадение между customer_id (таблицы Customers) и customer (таблицы Orders). */

/* Мы можем использовать псевдонимы (оператор AS) с именами таблиц, чтобы сделать код короче и чище. Например: */
SELECT C.customer_id, C.first_name, O.amount
FROM Customers AS C
JOIN Orders AS O
ON C.customer_id = O.customer;

/* Кроме того, мы также можем временно изменить и имена столбцов, используя псевдонимы. Например: */
SELECT C.customer_id AS cid, C.first_name AS name, O.amount
FROM Customers AS C
JOIN Orders AS O
ON C.customer_id = O.customer;

/* Примеры с использованием оператора JOIN: */
/* Есть две таблицы: 1)products; 2)product_types. Для связи между двумя таблицами в таблице products есть столбец type_id */

/* Вывести столбец name таблицы products и столбец type_name таблицы product_types */
SELECT products.name, product_types.type_name
FROM products JOIN product_types
ON products.type_id = product_types.id


/* ПСЕВДОНИМЫ ТАБЛИЦ для сокращения записи громоздких запросов JOIN */
SELECT p.name, t.type_name
FROM products AS p JOIN product_types AS t
ON p.type_id = t.id

/* ПСЕВДОНИМЫ столбцов и ТАБЛИЦ для сокращения записи громоздких запросов JOIN */
SELECT p.name AS product_name, 
       t.type_name AS product_type.
	   p.price AS product_price,
FROM products AS p JOIN product_types AS t
ON p.type_id = t.id

/* ЗАПРОС ДАННЫХ ИЗ НЕСКОЛЬКИХ ТАБЛИЦ (JOIN) с ФИЛЬТРАЦИЕЙ ДАННЫХ (WHERE) */
SELECT p.name AS product_name, 
       t.type_name AS product_type.
	   p.price AS product_price,
FROM products AS p JOIN product_types AS t
ON p.type_id = t.id
WHERE t.type_name = 'Вебинар'
AND p.price = 0;


                 ----------- Типы операторов JOIN ----------
				 
1) --- Оператор INNER JOIN в SQL
/* Оператор INNER JOIN объединяет две таблицы на основе общего столбца и выбирает записи с совпадающими значениями в этих столбцах. Например: */
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
INNER JOIN Orders
ON Customers.customer_id = Orders.customer
WHERE Orders.amount >= 500;
/* Здесь мы объединяем две таблицы и выбираем строки, в которых сумма (amount) больше или равна 500. */

--- Оператор INNER JOIN с тремя таблицами
/* Мы также можем объединить более двух таблиц, используя оператор INNER JOIN. Например: */
SELECT C.customer_id, C.first_name, O.amount, S.status
FROM Customers AS C
INNER JOIN Orders AS O
ON C.customer_id = O.customer
INNER JOIN Shippings AS S
ON C.customer_id = S.customer;
/* Здесь мы:
   объединяем таблицы Customers и Orders на основе customer_id;
   объединяем таблицы Customers и Shippings на основе customer_id.
Команда возвращает те строки, в которых есть совпадение между значениями столбцов в обоих условиях объединения. */

2) --- Оператор LEFT JOIN в SQL
/* Оператор LEFT JOIN объединяет две таблицы на основе общего столбца и выбирает не только записи с совпадающими значениями в этих столбцах, но и все оставшиеся строки из левой таблицы. Например: */
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
LEFT JOIN Orders
ON Customers.customer_id = Orders.customer;
/* Здесь мы выбираем столбцы customer_id и first_name (из таблицы Customers) и столбец amount (из таблицы Orders). В результате получаем те строки, в которых есть совпадение между customer_id (таблицы Customers) и customer (таблицы Orders) вместе со всеми остальными строками из (левой) таблицы Customers. */

3) --- Оператор RIGHT JOIN в SQL
/* Оператор RIGHT JOIN объединяет две таблицы на основе общего столбца и выбирает не только записи с совпадающими значениями в этих столбцах, но и все оставшиеся строки из правой таблицы. Например: */
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
RIGHT JOIN Orders
ON Customers.customer_id = Orders.customer;
/* Здесь мы выбираем столбцы customer_id и first_name (из таблицы Customers) и столбец amount (из таблицы Orders). В результате получаем те строки, в которых есть совпадение между customer_id (таблицы Customers) и customer (таблицы Orders) вместе со всеми остальными строками из (правой) таблицы Orders. */

4) --- Оператор FULL OUTER JOIN в SQL
/* Оператор FULL OUTER JOIN объединяет две таблицы на основе общего столбца и выбирает не только записи с совпадающими значениями в этих столбцах, но и все оставшиеся строки из обеих таблиц. Например: */
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
FULL OUTER JOIN Orders
ON Customers.customer_id = Orders.customer;
/* Здесь мы выбираем столбцы customer_id и first_name (из таблицы Customers) и столбец amount (из таблицы Orders). В результате получаем те строки, в которых есть совпадение между customer_id (таблицы Customers) и customer (таблицы Orders) вместе со всеми остальными строками из обеих таблиц. */



/* ========================================================================== */

----------- Подзапросы в SQL (SUBQUERIES) ----------
/* В SQL мы можем поместить один запрос внутри другого запроса (сделав подзапрос). В подзапросе результат внешнего запроса зависит от результатов внутреннего запроса. Вот почему подзапросы также называют вложенными запросами. Подзапросы оформляются в круглых скобках.
Например: */
SELECT *
FROM Customers
WHERE age = (
  SELECT MIN(age)
  FROM Customers
);
/* Здесь сначала выполняется подзапрос (внутренний запрос) — мы выбираем наименьшее значение age из таблицы Customers. Затем выполняется внешний запрос — мы выбираем строки, в которых age равен результату подзапроса (наименьшему значению age). */

/*Рассмотрим другой пример. Предположим, нам нужны сведения о клиентах, разместивших заказ. Вот как мы можем это сделать с помощью подзапроса: */
SELECT customer_id, first_name
FROM Customers 
WHERE customer_id IN (
  SELECT customer_id
  FROM Orders
);
/* Сначала мы выбираем customer_id из таблицы Orders, затем выбираем строки из таблицы Customers, в которых customer_id совпадает с результатами подзапроса. */


/* Вывести id, name и price из таблицы products, где price равен подзапросу */
SELECT id, name, price
FROM products
WHERE price = (SELECT MAX(price) FROM products)  -- <--- данное вырежение в скобках является подзапросом


/* Вывести информацию о продуктах, которые были проданы хотя бы один раз.
Информация о продуктах хранится в таблице products, а информация о продажах в таблице sales */
SELECT id, name, price
FROM products
WHERE id IN (SELECT product_id FROM sales) 
/* здесь подзапрос возвращает не одно значение, а список. Поэтому простое сравнение использовать нельзя, а вместо этого мы используем оператор IN. */

/* Подзапросы в UPDATE */
/* Например, нам нужно увеличить стоимсоть каждой книги, которую продаёт онлайн-школа, на 500 рублей. */

UPDATE products
SET price = price + 500
WHERE type_id = (SELECT id FROM product_types WHERE type_name = 'Книга')



/* ========================================================================== */

------------- /* TRANSACTIONS (ТРАНЗАКЦИИ) */ ---------------
/* ТРАНЗАКЦИИ - это последовательность команд SQL, которые должны быть выполнены ПОЛНОСТЬЮ или не выполнены вообще */

START TRANSACTION;   --- начало транзакции

UPDATE accounts SET balance = balance - 15000   --- уменьшение баланса счёта клиента
WHERE account_number = 1234567;                  

UPDATE accounts SET balance = balance + 15000   --- увеличение баланса счёта онлайн-школы
WHERE account_number = 9876543;

COMMIT; --- 1-й вариант - зафиксировать транзакцию (изменения будут записаны в базу данных)

ROLLBACK; --- 2-й вариант - откат транзакции (если что-то пошло не так) - все команды, которые были введены со старта транзакции будут отменены.



----------------- Требования ACID в базах данных ----------------

/* Транзакция — это некий набор связанных операций с базой данных. Этот набор операций должен представлять единую логическую систему с данными.
Требования ACID — набор требований, которые обеспечивают сохранность ваших данных. Что особенно важно для финансовых операций. Мы же не хотим остаться без денег из-за разрыва соединения или ошибки в ПО, не так ли?
 
-----> Atomicity (Атомарность).
Атомарность - неделимость, означает, что либо будут выполнены все действия транзакции, либо никакие. 
Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. 
Не допускаются промежуточные состояния.
Рассмотрим пример с переводом денежных средств между двумя лицевыми счетами. Мы установили, что эти 2 операции, которые взаимодействуют с базой данных, являются операциями транзакции. А какие проблемы могут возникнуть, если мы просто выполним эти операции последовательно, отправив два запроса к БД?
Первый запрос выполнится успешно. С первого лицевого счета будет списана N-ая сумма денежных средств.
Однако, в случае той или иной технической ошибки во время выполнения второго запроса может случиться так, что денежные средства с одного лицевого счета уйдут, а на другой счет не поступят.
В этой ситуации речь идет о проблеме потери данных. В целях снижения этого риска транзакции обладают таким свойством, как атомарность (atomicity), неделимость: либо будут выполнены все действия транзакции, либо никакие.

-----> Consistency — Согласованность. 
Это свойство вытекает из предыдущего. Благодаря тому, что транзакция не допускает промежуточных результатов, база остается консистентной. Есть такое определение транзакции: «Упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое». То есть до выполнения операции и после база остается консистентной (в переводе на русский — согласованной).

-----> Isolation — Изолированность. 
Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.
Если система рассчитана на одного пользователя — все будет хорошо, а если пользователей много?
Тогда операции необходимо запускать на параллельной основе, чтобы система могла работать в ускоренном режиме.
Но тут могут скрываться крайне неприятные подводные камни:
--> Проблема №1 — Потерянная запись;
--> Проблема №2 — Повторяемое чтение;
--> Проблема №3 — Грязное чтение;
--> Проблема №4 — Фантом.
Решение всех этих проблем основано на использовании как раз изолированной транзакции.
Как этого достичь?
Например, использовать блокировку версий.
Данная манипуляция подразумевает под собой блокирование определенной строки в таблице (можно заблокировать данные как на добавление, так и на редактирование).

-----> Durability — Надёжность (долговечность, прочность).
Надёжность (прочность, долговечность) означает, что если транзакция выполнена, и даже если в следующий момент произойдет сбой в системе, результат сохранится.
Если вы пользуетесь облачными хранилищами, такими как Amazon S3, то могли заметить, что разные тарифы обещают вам разное количество девяток durability. В контексте облака  durability означает сохранность ваших данных и то, как они реплицируются. Чем больше копий ваших данных в разных точках мира, тем выше вероятность их не потерять из-за наводнения, землетрясения или нашествия инопланетян. В контексте «ACID» это обычно означает, что после фиксирования данные записываются в постоянное хранилище.

*/

--- (про транзакции см. также ниже в разделе TCL-операторы)




/* ========================================================================== */

--------------- /* ОГРАНИЧЕНИЯ В БАЗАХ ДАННЫХ (CONSTRAINTS) */ ---------------

/* Ограничения – это правила, применяемые к столбцам данных в таблице. Они используются для предотвращения ввода неверных данных в базу данных. Это обеспечивает точность и достоверность данных в базе данных. */

--------------------------  1. Ограничения NOT NULL  -------------------------
/* Ограничение NOT NULL просто указывает, что столбцу нельзя присваивать значение NULL. Пример синтаксиса: */

CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);

-----------------------  2. Ограничения-проверки (CHECK) -------------------------
/*Ограничение-проверка — наиболее общий тип ограничений. В его определении вы можете указать, что значение данного столбца должно удовлетворять логическому выражению (проверке истинности). Ограничение-проверка состоит из ключевого слова CHECK, за которым идёт выражение в скобках. Это выражение должно включать столбец, для которого задаётся ограничение, иначе оно не имеет большого смысла. Например, цену товара можно ограничить положительными значениями так: */

CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);

/* Вы можете также присвоить ограничению отдельное имя. Это улучшит сообщения об ошибках и позволит вам ссылаться на это ограничение, когда вам понадобится изменить его. Чтобы создать именованное ограничение, напишите ключевое слово CONSTRAINT, а за ним идентификатор и собственно определение ограничения. (Если вы не определите имя ограничения таким образом, система выберет для него имя за вас.) НАПРИМЕР: */

CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);

/* Ограничение-проверка может также ссылаться на несколько столбцов. Например, если вы храните обычную цену и цену со скидкой, так вы можете гарантировать, что цена со скидкой будет всегда меньше обычной: */

CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);

/* Первые два ограничения определяются похожим образом, но для третьего используется новый синтаксис. Оно не связано с определённым столбцом, а представлено отдельным элементом в списке. Определения столбцов и такие определения ограничений можно переставлять в произвольном порядке.
Про первые два ограничения можно сказать, что это ограничения столбцов, тогда как третье является ограничением таблицы, так как оно написано отдельно от определений столбцов. Ограничения столбцов также можно записать в виде ограничений таблицы, тогда как обратное не всегда возможно, так как подразумевается, что ограничение столбца ссылается только на связанный столбец.

Ранее приведённый пример можно переписать и так: */

CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);


-----------------------  3. Ограничения уникальности (UNIQUE) -------------------------
/* Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы. Ограничение записывается так: */

-- 1) в виде ограничения столбца:
CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);

-- 2) в виде ограничения таблицы:
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE (product_no)
);

-----------------------  4. Первичные ключи (PRIMARY KEY) -------------------------
/* Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были одновременно уникальными и отличными от NULL. Таким образом, таблицы со следующими двумя определениями будут принимать одинаковые данные: */

CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);

CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);


/* Первичные ключи могут включать несколько столбцов; синтаксис следующий: */
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    PRIMARY KEY (a, c)
);


-----------------------  5. Внешние ключи (FOREIGN KEY) -------------------------
/* Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целостностью двух связанных таблиц. */

-- Пусть у вас уже есть таблица продуктов
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

/* Давайте предположим, что у вас есть таблица с заказами этих продуктов. Мы хотим, чтобы в таблице заказов содержались только заказы действительно существующих продуктов. Поэтому мы определим в ней ограничение внешнего ключа, ссылающееся на таблицу продуктов: */
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);

/* С таким ограничением создать заказ со значением product_no, отсутствующим в таблице products (и не равным NULL), будет невозможно. */

/* В такой схеме таблицу orders называют подчинённой таблицей, а products — главной. Соответственно, столбцы называют так же подчинённым и главным (или ссылающимся и целевым).

Предыдущую команду можно сократить так: */

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products,
    quantity integer
);

/* то есть, если опустить список столбцов, внешний ключ будет неявно связан с первичным ключом главной таблицы. */


-----------------------  6. Значение по умолчанию (DEFAULT) -------------------------
/* Ограничение DEFAULT используется для предоставления значения по умолчанию для столбца. Значение по умолчанию будет добавлено ко всем новым записям, если другое значение не указано.
Следующий SQL устанавливает значение DEFAULT для столбца «country», когда создается таблица «users»: */
CREATE TABLE users (
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    country varchar(255) DEFAULT 'Spain'
);

/* Чтобы создать ограничение DEFAULT в столбце «country», когда таблица уже создана, используйте следующее: */
ALTER TABLE users
ALTER country SET DEFAULT 'Spain';


/* Чтобы удалить ограничение DEFAULT, используйте следующее: */
ALTER TABLE users
ALTER country DROP DEFAULT;



/* ========================================================================== */

------------------- ПРЕДСТАВЛЕНИЯ в SQL (VIEW) ---------------------
/* Представление — это способ задать ИМЯ для запроса SELECT на выборку данных и по этому ИМЕНИ быстро получать нужную «собранную» таблицу. То есть можно создать сложный запрос в базу данных и дать ему имя, чтобы каждый раз не расписывать полный SELECT. */

-- Например, можно создать представление, содержащее нужные нам поля из одной таблицы.
CREATE VIEW customers_v AS
SELECT id, name FROM customers;

/* Пример №2. У нас в базе данных есть три связанных таблицы: 1) Products; 2) Customers; 3) Orders. 
Добавим в базу данных, в которой содержатся 3 данные таблицы, представление OrdersProductsCustomers: */
CREATE VIEW OrdersProductsCustomers AS
SELECT Orders.CreatedAt AS OrderDate,
       Customers.FirstName AS Customer,
       Products.ProductName As Product  
FROM Orders 
INNER JOIN Products ON Orders.ProductId = Products.Id
INNER JOIN Customers ON Orders.CustomerId = Customers.Id;

-- данное представление фактически будет возвращать сводные данные из трех таблиц.

-- Теперь используем созданное выше представление для получения данных:
SELECT * FROM OrdersProductsCustomers;

-- Также при создании представления можно определить набор его столбцов:
CREATE VIEW OrdersProductsCustomers2 (OrderDate, Customer, Product)
AS SELECT Orders.CreatedAt,
        Customers.FirstName,
        Products.ProductName
FROM Orders INNER JOIN Products ON Orders.ProductId = Products.Id
INNER JOIN Customers ON Orders.CustomerId = Customers.Id;


------------ /* Материализованные представления */ -----------
/* Представления не содержат данные. А когда происходят запросы к представлениям, данные извлекаются из исходных таблиц, на основе котрых созданы представления.
Однако существует другой вариант - материализованные представления, которые СОДЕРЖАТ данные. Данный вид представлений поддреживают не все СУБД, но PostgreSQL и Oracle поддерживают материализованные представления. */
CREATE MATERIALIZED VIEW products_v
AS SELECT Orders.CreatedAt AS OrderDate, 
        p.id AS id,
        p.name AS product_name,
        t.type_name AS product_type,
		p.price AS product_price
FROM products AS p
JOIN product_types AS t
	ON p.type_id = t.Id;

/* Недостаток в том, что данные в исходных таблицах обновляются, а в материализованном представлении эти изменения не учитываются. Поэтому для материализованного представления необходимо периодически запускать обновление с помощью команды REFRESH */
REFRESH MATERIALIZED VIEW products_v;

------------ /* Удаление представлений */ -----------
DROP VIEW products_v;
DROP MATERIALIZED VIEW products_v;



/* ========================================================================== */
--------------------- Оператор UNION и UNION ALL в SQL --------------------

-- Источник №1.
/* Оператор UNION в SQL выбирает строки из двух или более таблиц. 
Если строки в таблицах повторяются, то они выводятся только один раз (т.е. без дублей). Например: */
SELECT age
FROM Teachers
UNION
SELECT age
FROM Students;
-- Здесь мы извлекаем столбец age из таблиц Teachers и Students, игнорируя повторяющиеся строки.


-- Источник №2.
/* UNION – это оператор SQL для объединения результирующего набора данных нескольких запросов, и данный оператор выводит только уникальные строки в запросах.
Т.е. если например, вы объединяете два запроса, в каждом из которых есть одинаковые данные, другими словами полностью идентичные, и оператор UNION объединит их в одну строку для того чтобы не было дублей;
UNION ALL – это оператор SQL для объединения результирующего набора данных нескольких запросов. 
Данный оператор выведет уже абсолютно все строки, даже дубли. */

SELECT model, price FROM PC
UNION
SELECT model, price FROM Laptop
ORDER BY price DESC;

/* Требования для UNION, которые должны соблюдаться, и особенности:
1) Каждый оператор SELECT в UNION должен иметь одинаковое количество столбцов;
2) Столбцы должны иметь одинаковые типы данных;
3) Столбцы в каждом заявлении SELECT также должны располагаться в том же порядке;
4) В результирующих данных имена столбцов будут совпадать с именами столбцов первого запроса;
5) Можно применять ORDER BY ко всем результатам и указывать его можно только в конце всего запроса (после последнего SELECTа);
*/


------------------------- Оператор MINUS в SQL --------------------------
/* Оператор вычитает строки из двух наборов данных (т.е. из первого набора вычитается второй набор) */
SELECT phonenum FROM man
MINUS
SELECT phonenum FROM auto;
/* Из всех номеров телефона таблицы man вычитаем (исключаем) набор номеров телефона, которые есть в таблице auto. */


------------------------- Оператор INTERSECT в SQL --------------------------
/* Оператор INTERSECT выводит пересечение наборов данных (т.е. выводит только совпадающие строки) */
SELECT phonenum FROM man
INTERSECT
SELECT phonenum FROM auto;



/* ========================================================================== */
---------------------- Оператор ANY в SQL ---------------------
/* 1) Оператор ANY сравнивает значение первой таблицы со всеми значениями второй таблицы и возвращает строку, если есть совпадение с каким-либо значением. Например, если мы хотим найти учителей, чей возраст аналогичен возрасту любого ученика, мы можем использовать: */
SELECT *
FROM Teachers
WHERE age = ANY (
  SELECT age
  FROM Students
);

/* Подзапрос [SELECT age FROM Students] возвращает все возрасты из таблицы Students.
   А условие WHERE age = ANY (...) сравнивает возраст учащихся (возвращается от подзапроса) с возрастом учителя. При наличии совпадения выбирается соответствующая строка таблицы Teachers. */


---------------------- Оператор ALL в SQL ---------------------
/*Оператор ALL сравнивает значение первой таблицы со всеми значениями второй таблицы и возвращает строку, если есть совпадение со всеми значениями. Например, если мы хотим найти учителей, чей возраст больше, чем у всех учеников, мы можем использовать: */
SELECT * 
FROM Teachers
WHERE age > ALL (
  SELECT age
  FROM Students
);

/* Подзапрос [SELECT age FROM Students] возвращает все возрасты из таблицы Students.
А условие WHERE age > ALL (...) сравнивает возраст учащихся (возвращается от подзапроса) с возрастом учителя. Если возраст учителя больше, чем возраст всех учеников, выбирается соответствующая строка таблицы Teachers. */

---------------------- Оператор EXISTS в SQL ---------------------
/* Оператор EXISTS выполняет внешний запрос SQL, если внутренний запрос (подзапрос) не возвращает NULL. Принцип работы оператора EXISTS: 
Запускается внешний запрос --> Запускается внутренний запрос (подзапрос) --> далее могут быть два варианта:
1) Если внутренний запрос возвращает NULL --> Результат выполнения внешнего запроса игнорируется;
2) Если внутренний запрос возвращает NULL --> Результат выполнения внешнего запроса отображается;
Этот процесс повторяется для каждой строки внешнего запроса.
Рассмотрим пример. Предположим, нам нужно вывести всех клиентов, совершивших заказ. В подзапросе мы проверяем наличие совершенного заказа в клиента (по полю customer_id) и если это подтверждается, то в результате выводим идентификатор и имя клиента. */
SELECT customer_id, first_name
FROM Customers
WHERE EXISTS (
  SELECT order_id
  FROM Orders
  WHERE Orders.customer_id = Customers.customer_id
);

---------------------- Оператор NOT EXISTS в SQL ---------------------
/* Мы также можем использовать оператор NOT, чтобы инвертировать работу оператора EXISTS. Команда SQL выполняется, если подзапрос возвращает пустой результат (т.е. NULL-значение). Например, выполним предыдущую SQL-команду, но уже с оператором NOT EXISTS: */
SELECT customer_id, first_name
FROM Customers
WHERE NOT EXISTS (
  SELECT order_id
  FROM Orders
  WHERE Orders.customer_id = Customers.customer_id
);
/* Здесь мы выводим всех клиентов, которые НЕ совершили заказ. */




/* ========================================================================== */

---------------------- Функция CASE в SQL ---------------------
/* Функция CASE в SQL используется для проверки условий и выполнения операций над данными. Синтаксис выражения CASE всегда начинается с ключевого слова CASE и заканчивается ключевым словом END, за которым следует псевдоним (оператор AS) имени столбца. Например: */
SELECT customer_id, first_name,
CASE
  WHEN age >= 18 THEN 'Allowed'
END AS can_vote
FROM Customers;
/* Здесь мы проверяем каждую строку на соответствие заданному выражению CASE и выполняем дополнительное действие в случае соответствия. Если возраст (age) больше или равен 18, то выбираются соответствующие строки customer_id и first_name и добавляется дополнительный столбец can_vote со значением Allowed. */


/* Оператор CASE совместно с опертаором UPDATE.
Если требуется изменять данные в зависимости от содержимого некоторого столбца, можно также воспользоваться выражением CASE. Если, скажем, нужно поставить жесткие диски объемом 20 Гбайт на портативные компьютеры с памятью менее 128 Мбайт и 40 гигабайтные — на остальные портативные компьютеры, то можно написать такой запрос: */
UPDATE Laptop
SET hd = CASE 
WHEN ram < 128 THEN 20
ELSE 40 
END;



			------------ ПРИМЕР 3 ------------
/* Возьмем для примера следующую таблицу Products: */
CREATE TABLE Products
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName VARCHAR(30) NOT NULL,
    Manufacturer VARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
);

--- Выполним запрос к этой таблице и используем функцию CASE:
SELECT ProductName, Manufacturer,
    CASE ProductCount
        WHEN 1 THEN 'Товар заканчивается'
        WHEN 2 THEN 'Мало товара'
        WHEN 3 THEN 'Есть в наличии'
        ELSE 'Много товара'
    END AS EvaluateCount
FROM Products

/* Здесь значения столбца ProductCount последовательно сравнивается со значениями после операторов WHEN. В зависимости от значения столбца ProductCount функция CASE будет возвращать одну из строк, которая идет после соответствующего оператора THEN. Для возвращаемого результата определен столбец EvaluateCount. */




/* ========================================================================== */

---------------------- Группы операторов в SQL ---------------------
/* С точки зрения реализации язык SQL представляет собой набор операторов, которые делятся на определенные группы и у каждой группы есть свое назначение. 
В сокращенном виде эти группы называются DDL, DML, DCL и TCL. */


------- DDL – Data Definition Language (Язык определения данных) -------

/* Data Definition Language (DDL) – это группа операторов определения данных. 
Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их.

В эту группу входят следующие операторы:

CREATE – используется для создания объектов базы данных;
ALTER – используется для изменения объектов базы данных;
DROP – используется для удаления объектов базы данных.
TRUNCATE - используется для удаления всех строк из таблицы и освобождения места, содержащего таблицу.



*/


------- DML – Data Manipulation Language (Язык манипулирования данными) -------

/* Data Manipulation Language (DML) – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими. 
В эту группу входят самые распространённые операторы языка SQL:

SELECT – осуществляет выборку данных;
INSERT – добавляет новые данные;
UPDATE – изменяет существующие данные;
DELETE – удаляет данные.

*/

------- TCL – Transaction Control Language (Язык управления транзакциями) -------

/* Transaction Control Language (TCL) – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены.
Важным моментом транзакции является то, что она объединяет несколько шагов в единую операцию «все или ничего». Промежуточные состояния между шагами не видны другим параллельным транзакциям, и если происходит какой-то сбой, препятствующий завершению транзакции, то ни один из шагов вообще не влияет на базу данных.
Эти команды (TCL) управляют обработкой транзакций в базе данных. Например, откат, сохранение, фиксация. 
Команды TCL можно использовать только с командами DML, такими как INSERT, DELETE и UPDATE.
Эти операции автоматически фиксируются в базе данных, поэтому их нельзя использовать при создании или удалении таблиц.

*/


/* 1. COMMIT (фиксация транзакции). Команда COMMIT используется для сохранения всех изменений, сделанных в БД в текущей транзакции. */
-- Синтаксис команды COMMIT следующий:
COMMIT;
-- or --
END TRANSACTION;


/* 2. ROLLBACK (откат транзакции). Команда отката используется для отмены изменений, сделанных в БД в текущей транзакции.
Синтаксис команды ROLLBACK следующий: */
ROLLBACK;


/* 3. SAVEPOINT (дословно - "точка сохранения"). Используется для отката транзакции до определенной точки без отката всей транзакции, т.е. для определения идентификатора, указывающего на именованную точку сохранения транзакции.
Операторы в транзакции можно контролировать более детально, используя точки сохранения. Точки сохранения позволяют вам выборочно отбрасывать части транзакции, сохраняя при этом остальные. После определения точки сохранения с помощью SAVEPOINT, вы можете при необходимости вернуться к точке сохранения с помощью ROLLBACK TO. Все изменения базы данных транзакции между определением точки сохранения и откатом к ней отбрасываются, но изменения до точки сохранения сохраняются.
Синтаксис: */
SAVEPOINT savepoint_name;
ROLLBACK TO savepoint_name;

--- Как удалить точку сохранения (savepoint):
RELEASE SAVEPOINT savepoint_name;


/* В PostgreSQL транзакция создается путем окружения SQL-команд транзакции командами BEGIN и COMMIT. Например, рассмотрим базу данных банка, которая содержит остатки по различным счетам клиентов, а также общие остатки по депозитам в филиалах. Предположим, что мы хотим записать платеж в размере 100 долларов со счета Алисы на счет Боба. Возмутительно упрощая, SQL-команды для этого могут выглядеть так: */
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- etc etc
COMMIT;


------- Начало транзакции -----
-- Ниже приведен простой синтаксис для запуска транзакции:
BEGIN;
-- or --
BEGIN TRANSACTION;

------- Фиксация (сохранение) изменений, вызванных транзакцией -----
-- Синтаксис команды COMMIT следующий:
COMMIT;
-- or --
END TRANSACTION;



/* Рассмотрим пример транзакции с точками сохраннения (SAVEPOINT). Вспоминая банковскую базу данных, предположим, что мы дебетуем 100 долларов со счета Алисы и кредитуем счет Боба, но позже обнаруживаем, что должны были кредитовать счет Уолли. Мы могли бы сделать это, используя такие точки сохранения: */
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- oops ... forget that and use Wally's account
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;




--------- DCL – Data Control Language (Язык управления данными) ---------

/* Data Control Language (DCL) – группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных. 

Сюда входят: 

1. GRANT – используется для предоставления пользователю или группе прав доступа к базе данных (разрешения на определённые операции с объектом);
Синтаксис: GRANT privileges ON object TO user;

Пример: */
GRANT SELECT, UPDATE ON my_table TO SOME_USER, ANOTHER_USER;


/* 2. REVOKE – отзывает выданные разрешения;
Синтаксис: REVOKE privileges ON object FROM user;
Пример: */
REVOKE SELECT, UPDATE ON my_table FROM USER1, USER2;



/* ========================================================================== */
---------------------- СТРОКОВЫЕ ФУНКЦИИ в SQL ---------------------

/* 
------------ Конкатенация строк ------------
Часто в запросах приходится объединять несколько значений в одно текстовое значение (конкатенация). Например, может потребоваться получить строку следующего формата: 'текущее время: 2019-02-19 15:28:44.049702+07'. */

-- Для выполнения конкатенации строк необходимо воспользоваться оператором ||: 
SELECT 'текущее время: ' || now() as time;

-- Либо функцией concat:
SELECT concat('текущее время: ', now()) as time;

-- Конкатенировать можно произвольное количество значений. 
-- Оператором || :
SELECT 'один, ' || 'два, ' || 'три' as result;

-- Функцией concat:
SELECT concat('один, ', 'два, ', 'три') as result;

-- Из таблицы employee получи один столбец full_name в формате 'first_name last_name'
SELECT CONCAT(first_name, ' ', last_name) AS full_name
FROM employee;




------------ Преобразование регистра букв ------------
/* В PostgreSQL есть три функции для изменения регистра символов строки:

lower - преобразование символов в нижний регистр;
upper - преобразование символов в верхний регистр;
initcap - преобразование первого символа каждого слова в верхний регистр, а остальных в нижний. 
*/

SELECT lower('Мама мыла РАМУ'); -- результат: одна ячейка со значением 'мама мыла раму'.

SELECT upper('Мама мыла РАМУ') -- результат: одна ячейка со значением 'МАМА МЫЛА РАМУ'.


/* С lower и upper все предельно просто. Давай еще поразбираемся с initcap. Словами в initcap считаются последовательности алфавитно-цифровых символов, разделённые любыми другими символами. Слова начинаются с буквы. */

-- Выполним еще несколько запросов:
SELECT initcap('Раз, два, три'); -- результат: одна ячейка со значением 'Раз, Два, Три'.

-- Разделим слова другими символами
SELECT initcap('Раз-два#три'); -- результат: одна ячейка со значением 'Раз-Два#Три'.

-- А если использовать цифры в качестве разделителя?
SELECT initcap('1раз два3три'); -- результат: одна ячейка со значением '1Раз Два3три'.


------------ Функция LENGTH ------------
-- Функция LENGTH используется для подсчета количества символов в строках. Синтаксис:
SELECT LENGTH(поле) FROM имя_таблицы WHERE условие

-- Пример 1 : 
/* В данном примере при выборке из таблицы создается дополнительное поле, которое содержит длину поля name: */
SELECT id, name, LENGTH(name) as length FROM users


-- Пример 2: 
-- Конечно, не обязательно делать поле length, чтобы применить функцию LENGTH в условии:
SELECT id, name FROM users WHERE LENGTH(name)>=7;

/* В данном примере с помощью условия WHERE выбираются только те записи, 
в которых длина поля name больше или равна 7. */



/* ========================================================================== */
---------------------- МАТЕМАТИЧЕСКИЕ ФУНКЦИИ в SQL ---------------------

------------ Функция ROUND ------------
/* Функция ROUND используется для округления дробей до нужного знака в дробной части.  */

----- Синтаксис:
-- Округление до целого:
SELECT ROUND(поле) FROM имя_таблицы WHERE условие

-- Округление до определенного знака в дробной части:
SELECT ROUND(поле, сколько_знаков_оставить) FROM имя_таблицы WHERE условие

-- Пример 1 
-- В данном примере дробная зарплата округляется до целых при выборке:
SELECT *, ROUND(salary) as salary FROM employees;

-- Пример 2 
-- В данном примере дробная зарплата округляется до двух знаков после точки:
SELECT *, ROUND(salary, 2) as salary FROM employees;

-- Пример 3
-- В данном примере дробная зарплата округляется до одного знака после точки:
SELECT *, ROUND(salary, 1) as salary FROM employees;



------------ Функция FLOOR ------------
/* Функция FLOOR используется для округления дробей до целого в меньшую сторону. */

----- Синтаксис:
SELECT FLOOR(поле) FROM имя_таблицы WHERE условие;

-- Пример 1: 
-- В данном примере дробная зарплата округляется до целых в меньшую сторону:
SELECT *, FLOOR(salary) as floor_salary FROM employees;



/* ========================================================================== */
-------------- /* ФУНКЦИЯ TIMEDIFF (для MySQL)*/ -------------
/* Возвращает разницу во времени (datetime1 - datetime2) между DATETIME или TIME значениями. 
Результат возвращается в формате ЧЧ:ММ:СС.

TIMEDIFF(datetime1, datetime2)

Возвращает NULL, если одно из переданных значений равно NULL или оба значения имеют разный тип.

Примеры */

SELECT TIMEDIFF('2022-12-05 18:00:00','2022-12-05 14:00:00');

SELECT TIMEDIFF('2022-12-05 18:00:00','2021-12-01 14:00:00');

SELECT TIMEDIFF('2022-12-05 14:00:00','2022-12-05 18:00:00');

SELECT TIMEDIFF('18:00:00','14:00:00');

SELECT TIMEDIFF('18:00:00','2022-12-05 14:00:00');



/* ========================================================================== */
---------------------- /* Нормализация БД */ ---------------------
/* 
1) Нормализация БД — это процесс организации данных определенным образом и рекомендации по проектированию. 
То есть таблицы и связи между ними (отношения) создаются в соответствии с правилами. 
В результате обеспечивается нужный уровень безопасности данных, а сама база становится более гибкой. 
Также устраняются несогласованные зависимости и избыточность.

2) Нормализация базы данных - это метод создания таблиц БД со столбцами и ключами путем разделения (или декомпозиции) таблицы большего размера на небольшие логические единицы. В данном методе учитываются требования, предъявляемые к среде БД.

Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, 
возникающих при добавлении, редактировании и удалении кортежей (строк таблицы).

Аномалией называется такая ситуация в таблице БД, которая приводит к противоречию в БД либо существенно усложняет обработку БД. 
Причиной является излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей от НЕключевых атрибутов.

Типы аномалий:
- Аномалии вставки (добавления) возникают, когда информацию в таблицу нельзя поместить, пока она не полная, либо вставка записи требует дополнительного просмотра таблицы.
- Аномалии обновления (модификации) проявляются в том, что изменение одних данных может повлечь просмотр всей таблицы и соответствующее изменение некоторых других записей таблицы.
- Аномалии удаления — при удалении какого либо кортежа из таблицы может пропасть информация, которая не связана на прямую с удаляемой записью.

Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных 
для устранения из БД избыточных функциональных зависимостей между атрибутами (полями таблиц).


----------- Плюсы нормализации -----------
Нормализация не является обязательной, но приносит следующие преимущества:

--> 1) упрощается процесс выборки. Речь идет об упрощении работы по составлению запросов, то есть пользователь сможет получать нужную информацию относительно простыми запросами;
--> 2) обеспечивается максимальная целостность данных, устраняя аномалии вставки, обновления и удаления. 
Можно говорить о минимизации искажения информации и снижении вероятности потери данных;
--> 3) улучшается масштабируемость. При соблюдении правил нормализации формируются благоприятные предпосылки к росту БД;
--> 4) сводится к минимуму избыточность данных, что повышает эффективность использования памяти на сервере БД. 
Избыточность — известная проблема непродуктивного использования свободного места на жестком диске, затрудняющая обслуживание БД.
В отдельных случаях эту проблему усугубляет и то, что в случае необходимости изменения записей однотипных данных, хранимых в нескольких местах (таблицах), 
пользователю придется вносить требуемые изменения везде, что весьма трудоемкое занятие. 
Гораздо проще сделать так, чтобы, к примеру, данные о городах хранились только в таблице Cities и нигде больше. 
Если подытожить вышесказанное, избыточность предполагает дублирование данных, а это не только усложняет работу с БД, но и увеличивает ее размер;
--> 5) отсутствие несогласованных зависимостей. 
Несогласованные зависимости затрудняют доступ к данным, ведь путь к такой информации может быть неправилен и нелогичен. 
В той же таблице Cities логично искать города, количество жителей и т.п., но не адреса и имена жителей — 
для этой информации уже нужна другая таблица — Citizens.



--================ НОРМАЛЬНЫЕ ФОРМЫ ================--

При нормализации предполагается использование нормальных форм по отношению к структуре имеющихся данных. 
Есть несколько правил нормализации. Каждое из них носит название «нормальная форма» (НФ).
Таких форм (уровней) — семь, однако на практике для большей части приложений вполне достаточно нормализовать БД до третьей нормальной формы 
(строго говоря, БД и будет считаться нормализованной, когда к ней применяется 3НФ и выше).

---------- Первая нормальная форма (1НФ) ----------
Согласно правилам (требованиям) 1НФ:
--> 1) все атрибуты в таблице должны быть простыми; 
--> 2) все сохраняемые данные на пересечении столбцов и строк — содержать лишь скалярные значения.
Другими словами - все используемые домены должны содержать только скалярные значения.
Каждый элемент данных должен быть атомарным, т.е. относиться к какому либо атомарному типу. 
В качестве значений нельзя использовать такие структуры данных как массивы, списки, множества и другие составные типы, которые допускают разбиение на более мелкие элементы.
Т.е. если в одной ячейке содержится список из нескольких элементов (например: white, green, red) то это является нарушением требований 1НФ, т.к. данное значение атрибута НЕ является атомарным.
--> 3) не должно быть повторяющихся строк.


---------- Вторая нормальная форма (2НФ) ----------
Отношение (таблица) находится во 2-й НФ, если оно:
--> 1) находится в 1-й НФ;
--> 2) у каждой записи в базе данных должен быть первичный ключ;
--> 3) каждый неключевой атрибут зависит от первичного ключа (PK) ЦЕЛИКОМ, а не от какой-то его части.


---------- Третья нормальная форма (3НФ) ----------
Отношение (таблица) находится в 3-й НФ, если оно:
--> 1) находится во 2-й НФ;
--> 2) все неключевые атрибуты НАПРЯМУЮ (нетранзитивно) зависят только от первичного ключа, НО НЕ от других атрибутов.
Другими словами, не должно быть зависимостей одних НЕключевых атрибутов от других. Все атрибуты зависят только от первичного ключа.



------------------- ДЕНОРМАЛИЗАЦИЯ БД ------------------
Денормализация - умышленное отклонение от требований НФ с целью повысить быстродействие и снизить сложность схемы БД.
Примеры приёмов, ведущих к денормализации (и часто к повышению быстродействия):
--> объединение нескольких столбцов в один (напр. составные столбцы ФИО, Адрес, Паспортные данные);
--> включение в таблицу повторяемых столбцов, если их количество определено (напр. в таблице 2 раза встречаются столбцы № паспорта, серия паспорта (внутренний паспорт и загранпаспорт);
--> включение в таблицу столбцов, которые характеризуют не данную сущность, а другую (напр. информация о паспорте включается в таблицу "граждане";
--> включение в таблицу вычисляемых столбцов (напр. столбец "Повышающий коэффициент" для сотрудников, который вычисляется на основании других данных сотрудника).

*/
